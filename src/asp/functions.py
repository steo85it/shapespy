import os

import numpy as np
from utils.slurm_tools import call_script, check_output_script, popen_script
from utils.string_tools import extract_thresholds


def set_asp(dir):
    """
    Set filepath for Ames Stereo Pipeline (ASP).
    """
    global aspdir
    aspdir = dir

def mapproject(dem, from_, to, dirnam, from_cam=None, stdout=None, use_csm=True, **kwargs):
    """
    Python wrapper function for UNIX mapproject ASP command. Orthorectifies (map-projects) a 
    camera image onto a DEM or datum.
    
    Args:
        dem (str): filepath to a priori digital elevation model 
        from_ (str): filepath to image .cub files
        to (str): filepath to and naming convention of .tif files generated by map project
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains map project and bundle adjust result files in sub-directories as well as 
        the a priori dem
        stdout (str): filepath to redirect output to a log file, default value is None
        use_csm (bool): use of the CSM camera model (CSM information is contained in .json files), default value is True
    
    """

    if use_csm:
        from_img = from_
        if from_cam is None:
            from_cam = f"{('.').join(from_.split('.')[:-1])}.json"
        args = [dem, from_img, from_cam, to]  # , f"{imgnam}.cal.echo.cub", f"{out_prefix}{imgnam}_map.tif"]
    else:
        args = [dem, from_, to]  # , f"{imgnam}.cal.echo.cub", f"{out_prefix}{imgnam}_map.tif"]

    #print(kwargs)

    # add default compression
    if "tif_compress" not in kwargs:
        kwargs["tif_compress"] = "Deflate"

    for key, value in kwargs.items():
        args = args + [f"--{key.replace('_', '-')}", str(value)]

    # print(args)

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/mapproject',
                args=args, is_slurm=False, stdout=stdout)


def dem_mosaic(imgs, dirnam, stdout=None, **kwargs):
    """
    Python wrapper for UNIX dem_mosaic ASP command. Creates a mosaic of DEM files.
    
    Args:
        imgs (list): list of string filepaths to map-projected .tif files to mosaic
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains map project and bundle adjust result files in sub-directories as well as 
        the a priori dem 
        stdout (str): filepath to redirect output to a log file, default value is None
        
    """
    args = imgs  # , f"{imgnam}.cal.echo.cub", f"{out_prefix}{imgnam}_map.tif"]
    pwd = os.getcwd()

    # print(kwargs)
    for key, value in kwargs.items():
        if value == None:
            args = args + [f"--{key.replace('_', '-')}"]
        else:
            args = args + [f"--{key.replace('_', '-')}", str(value)]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/dem_mosaic',
                args=args, is_slurm=False, stdout=stdout)

    # go back to original dir
    # assert os.getcwd() == pwd, f"Current working directory {os.getcwd()} is not the same as initial one {pwd}"
    os.chdir(pwd)


def bundle_adjust(imglist, dem, dirnam, stdout=None, parallel=True, use_csm=True, use_mapproject=True, **kwargs):
    """
    Python wrapper for UNIX bundle_adjust ASP command. Bundle adjustment on a given set of images and cameras.
    
    Args:
        imglist (list of str): list of filepaths to .cub images
        dem (str): filepath to a priori digital elevation model
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains map project and bundle adjust result files in sub-directories as well as 
        the a priori dem
        stdout (str): filepath to redirect output to a log file, default value is None
        parallel (bool): use of parallel processing to complete computation, default is True
        use_csm (bool): use of the CSM camera model (CSM information is contained in .json files), default value is True
    
    """

    #imglist = imglist[:10]
    # add list of mapprojected files
    projlist = [f"{dirnam}prj/{x.split('.')[0]}_map.tif" for x in imglist] + [dem] 

    # generate list of images and cameras and pass them as input
    np.savetxt(f"{dirnam}image_list.txt", [f"{dirnam}{x}" for x in imglist], delimiter="\n", fmt='%s')
    if use_mapproject:
        np.savetxt(f"{dirnam}mapprojected_list.txt", projlist, delimiter="\n", fmt='%s')
  
    args = ["--image-list", f"{dirnam}image_list.txt"]
        
    if use_csm:
        camlist = [f"{dirnam}{x.split('.')[0]}.json" for x in imglist]
        np.savetxt(f"{dirnam}camera_list.txt", camlist, delimiter="\n", fmt='%s')
        args = args + ["--camera-list", f"{dirnam}camera_list.txt"]
    else:
        if os.path.isfile(f"{dirnam}camera_list.txt"):
            os.remove(f"{dirnam}camera_list.txt")
        os.mknod(f"{dirnam}camera_list.txt")
        #args = args + ["--camera-list", f"{dirnam}camera_list.txt"]
        
    if use_mapproject:
        #if use_csm:
            args = args + ["--mapprojected-data-list", f"{dirnam}mapprojected_list.txt"]
        #else:
        #    args = args + ["--mapprojected-data", (' ').join(projlist)]
            
    for key, value in kwargs.items():

        # skip certain keys if their value is None
        if key in ["input_adjustments_prefix", "match_files_prefix", "clean_match_files_prefix"]:
            if value is None:
                continue
            
        # skip certain keys
        if key in ["imglist"]:
            continue
        
        # special case for parallel_bundle_adjust getting a different parameter
        if key == 'output_prefix' and parallel:
            key = 'o'

        if len(key) > 2:
            if value is None:
                args = args + [f"--{key.replace('_', '-')}"]
            else:
                args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    print(args)

    # get map-projected images with asp
    if parallel:
        call_script(dirnam=dirnam, script=f'{aspdir}bin/parallel_bundle_adjust',
                args=args,
                is_slurm=False)
    else:
        call_script(dirnam=dirnam, script=f'{aspdir}bin/bundle_adjust',
                args=args,
                stdout=stdout,
                is_slurm=False)


def gdal_translate(dirnam, filin, filout, **kwargs):
    """
    Python wrapper for UNIX gdal_translate GDAL command (integrated into ASP). Converts 
    raster data between different formats.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        filin (str): filepath to original raster data
        filout(str): filepath to final raster data
        
    """

    pwd = os.getcwd()

    args = [filin, filout]
    for key, value in kwargs.items():
        if len(key) > 2:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    args = [arg.split(' ') for arg in args]
    args = [item for sublist in args for item in sublist]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/gdal_translate',
                args=args,
                is_slurm=False)

    # go back to original dir
    # assert os.getcwd() == pwd, f"Current working directory {os.getcwd()} is not the same as initial one {pwd}"
    os.chdir(pwd)

def pc_align(dirnam, point_clouds, stdout=None, **kwargs):
    """
    Python wrapper for UNIX pc_align ASP command. Aligns two point clouds, supports 
    feature-based alignment, and alignment using least squares.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        point_clouds (str): filepath to file containing point cloud (ASP point cloud, 
        GeoTIFF, ISIS cub, LAS, or csv file types)
    
    """

    args = point_clouds
    for key, value in kwargs.items():
        if len(key) > 2:
            if key == "max_displacement":
                args = [f"--{key.replace('_', '-')}", str(value)] + args
            else:
                if value != None:
                    args = args + [f"--{key.replace('_', '-')}", str(value)]
                else:
                    args = args + [f"--{key.replace('_', '-')}"]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    # print(args)
    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/pc_align',
                args=args,
                stdout=stdout,
                is_slurm=False)


def image_align(dirnam, images, stdout=None, **kwargs):
    """
    Python wrapper for UNIX image_align ASP command. Aligns a second image to a first image.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        images (list[str]): filepath to .tif map projected images that need to be aligned
        stdout (str, None): filepath to redirect output to a log file, default value is None
        
    """

    args = images
    for key, value in kwargs.items():
        if len(key) > 2:
            if value != None:
                args = args + [f"--{key.replace('_', '-')}", str(value)]
            else:
                args = args + [f"--{key.replace('_', '-')}"]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    # print(args)
    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/image_align',
                args=args,
                stdout=stdout,
                is_slurm=False)

def n_align(dirnam, point_clouds, get_output=False, **kwargs):
    """Python wrapper for UNIX n_align ASP command. Can be used to jointly align 
    a set of two or more point clouds, hence it extends the functionality of ASP 
    command pc_align.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        point_clouds (str): filepath to file containing point cloud (ASP point cloud, 
        GeoTIFF, ISIS cub, LAS, or csv file types)
        get_output(bool): if True, returns output from n_align UNIX command, default False
    
    """

    args = point_clouds
    for key, value in kwargs.items():
        if len(key) > 2:
            if value != None:
                args = args + [f"--{key.replace('_', '-')}", str(value)]
            else:
                args = args + [f"--{key.replace('_', '-')}"]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    # print(args)

    if get_output:
        return check_output_script(dirnam=dirnam, script=f'{aspdir}bin/n_align',
                args=args,
                is_slurm=False)
    else:
        call_script(dirnam=dirnam, script=f'{aspdir}bin/n_align',
                    args=args,
                    is_slurm=False)

def point2dem(dirnam, point_cloud, **kwargs):
    """Python wrapper for UNIX point2dem ASP command. Produces a digital elevation model
    (DEM) in the GeoTIFF format and/or an orthographic image from a set of point clouds.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        point_cloud (str): filepath to file containing point cloud (ASP point cloud, 
        GeoTIFF, ISIS cub, LAS, or csv file types)
    
    """

    args = [point_cloud]
    for key, value in kwargs.items():
        if len(key) > 1:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            print([f"-{key.replace('_', '-')}", str(value)])
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    # print(args)
    # run asp function
    call_script(dirnam=dirnam, script=f'{aspdir}bin/point2dem',
                args=args,
                is_slurm=False)

def sfs(imglist, dem, dirnam, in_ext=".cal.cub", out_prefix='sfs/run',
        parallel=False, use_csm=True, stdout=None, **kwargs):
    """
    Python wrapper for UNIX sfs ASP command. Can improve a DEM using shape-from-shading.
    
    Args:
        imglist (list str): list of filepaths to .cub images
        dem (str): filepath to a priori digital elevation model
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        in_ext (str): extension name for images, default is ".cal.cub"
        out_prefix (str): filepath prefix for output files, default is 'sfs/run'
        parallel (bool): use of parallel processing to complete computation, default is True
        use_csm (bool): use of the CSM camera model (CSM information is contained in .json files), default value is True
    
    """

    if use_csm:
        cubarr = [f"{x}{in_ext}" for x in imglist]
        csmarr = [f"{x}.json" for x in imglist]
        imgarr = cubarr + csmarr
    else:
        imgarr = [f"{x}{in_ext}" for x in imglist]
    
    args = ["-i", dem] + imgarr + ["-o", out_prefix]

    # print(kwargs)
    for key, value in kwargs.items():
        if value != None:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"--{key.replace('_', '-')}"]
    # print(args)
            
    # run asp function
    if parallel:
        call_script(dirnam=dirnam, script=f'{aspdir}bin/parallel_sfs',
                    args=args, is_slurm=False, stdout=stdout)
    else:
        call_script(dirnam=dirnam, script=f'{aspdir}bin/sfs',
                    args=args, is_slurm=False, stdout=stdout)


def sfs_blend(dirnam, lola_dem, sfs_dem, max_lit_image_mosaic, image_threshold=0.005,
              lit_blend_length=25, shadow_blend_length=5,
              output_dem='sfs_blend/run', output_weight='sfs_blend/weight',
              stdout=None, **kwargs):
    """
    Python wrapper for UNIX sfs_blend ASP command.

    Args:
        dirnam (str): filepath to directory in which to generate result files, generally
        contains mapproject and bundle adjust result files in sub-directories as well as
        the a priori dem
        dem (str): filepath to a priori digital elevation model
    """

    args_keys = ['lola_dem', 'sfs_dem', 'max_lit_image_mosaic', 'image_threshold',
              'lit_blend_length', 'shadow_blend_length',
              'output_dem', 'output_weight']
    args_values = [lola_dem, sfs_dem, max_lit_image_mosaic, image_threshold,
              lit_blend_length, shadow_blend_length,
              output_dem, output_weight]

    args = []
    for key, value in zip(args_keys, args_values):
        args = args + [f"--{key.replace('_', '-')}", str(value)]

    for key, value in kwargs.items():
        if value != None:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"--{key.replace('_', '-')}"]
    print(args)

    # run asp function
    call_script(dirnam=dirnam, script=f'{aspdir}bin/sfs_blend',
                args=args, is_slurm=False, stdout=stdout)


def hillshade(dem, dirnam, **kwargs):
    """
    Python wrapper for UNIX hillshade ASP command. Reads in a DEM and outputs an 
    image of that DEM as though it were a three-dimensional surface, with every 
    pixel shaded as though it were illuminated by a light from a specified location.
    
    Args:
        dem (str): filepath to a priori digital elevation model
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
    
    """

    args = [dem]

    # print(kwargs)
    for key, value in kwargs.items():
        if value != None:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"--{key.replace('_', '-')}"]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/hillshade',
                args=args, is_slurm=False)


def ipfind(dirnam, images, stdout=None, **kwargs):
    """Python wrapper for UNIX ipfind ASP command. Detects interest points (IPs) in 
    images and writes them out to .vwip files. ASP is able to read these files to 
    recover the IPs.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem 
        images (list str): list of filepaths to map projected images
    
    """

    args = images

    # print(kwargs)
    for key, value in kwargs.items():
        if value != None:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"--{key.replace('_', '-')}"]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/ipfind',
                args=args, is_slurm=False, stdout=stdout)


def ipmatch(dirnam, images, vwip=[], stdout=None, **kwargs):
    """
    Python wrapper for UNIX ipmatch ASP command. Reads interest points (IPs) 
    from .vwip files produced with ipfind and finds matches among them, writing 
    out .match files containing the results.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        images (str list): list of .tif filepaths that have been previously map projected
        vwip (str list): list of .vwip filepaths corresponding to the images argument, default empty list
    
    """

    args = images + vwip

    # print(kwargs)
    for key, value in kwargs.items():
        if value != None:
            args = args + [f"--{key.replace('_', '-')}", str(value)]
        else:
            args = args + [f"--{key.replace('_', '-')}"]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/ipmatch',
                args=args, is_slurm=False, stdout=stdout)


def parallel_stereo(dirnam, images, out_prefix, stdout=None, **kwargs):
    """Python wrapper for UNIX parallel_stereo ASP command (parallelized 
    version of stereo). Takes a stereo pair of images that overlap with 
    corresponding cameras and creates an output point cloud image that can 
    be processed into a visualizable mesh or a DEM using point2mesh and point2dem 
    respectively.
    
    Args:
        dirnam (str): filepath to directory in which to generate result files, generally 
        contains mapproject and bundle adjust result files in sub-directories as well as 
        the a priori dem
        images (list[str]): filepaths to stereo pair images
        stdout (str, None): filepath to file to write to stdout instead of writing to file
        out_prefix (str): filepath prefix for output files
    
    """

    if 'correlator_mode' in kwargs:
        args = ['--correlator-mode'] + images + [out_prefix]
    else:
        args = images + [out_prefix] # + ['-t', 'rpc']

    for key, value in kwargs.items():
        if key == 'correlator_mode':
            continue

        if len(key) > 2:
            if key in ['corr_kernel', 'corr_search']:
                args = args + [f"--{key.replace('_', '-')}"] + [str(x) for x in value]
            elif value != None:
                args = args + [f"--{key.replace('_', '-')}", str(value)]
            else:
                args = args + [f"--{key.replace('_', '-')}"]
        else:
            args = args + [f"-{key.replace('_', '-')}", str(value)]

    # print(args)
    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/parallel_stereo',
                args=args, stdout=stdout,
                is_slurm=False)

def cam_test(dirnam, prefix, cams=None, stdout=None, **kwargs):
    # cam_test --sample-rate 100 --image ../HLS/CH3/proc/tile_0/M1351501927LE.cub --cam1 ../HLS/CH3/proc/tile_0/M1351501927LE.cub --cam2 ../HLS/CH3/proc/tile_0/M1351501927LE.json

    if cams is None:
        args = [f"--image", f"{prefix}.cub", "--cam1", f"{prefix}.cub", "--cam2", f"{prefix}.json"]
    else:
        args = [f"--image", f"{prefix}.cub", "--cam1", cams[0], "--cam2", cams[1]]

    for key, value in kwargs.items():
        args = args + [f"--{key.replace('_', '-')}", str(value)]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/cam_test',
                args=args, is_slurm=False, stdout=stdout)

def usgscsm_cam_test(dirnam, input_camera_model, output_model_state, stdout=None, **kwargs):

    args = ['--model', input_camera_model, '--output-model-state', output_model_state]

    for key, value in kwargs.items():
        args = args + [f"--{key.replace('_', '-')}", str(value)]

    # get map-projected images with asp
    call_script(dirnam=dirnam, script=f'{aspdir}bin/usgscsm_cam_test',
                args=args, is_slurm=False, stdout=stdout)

def otsu_threshold(images, dirnam, pattern, stdout=None, **kwargs):

    import pandas as pd
    
    args = images

    for key, value in kwargs.items():
        if key not in ['timeout', 'delay']:
            args = args + [f"--{key.replace('_', '-')}", str(value)]

    output = popen_script(dirnam, script=f'{aspdir}bin/otsu_threshold', pattern=pattern,
                 timeout=kwargs['timeout'], delay=kwargs['delay'], kwargs=args)
    
    # return parsed thresholds
    return pd.DataFrame.from_dict([extract_thresholds(output, pattern=pattern)]).T
